# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил(а):
- Федоткина Екатерина 
- АИС-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Person:
    def __init__(self, name):
        self.name = name
    def guess_name(self, guessed_name):
        if guessed_name == self.name:
            return "Вы угадали мое имя!"
        else:
            return "Вы не угадали мое имя."

person = Person("Катя")
a = input("Введите имя: ")
print(person.guess_name(a))
```
### Результат.
![image](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/91.png)

## Выводы
- __init__(self, name): конструктор, который принимает имя и сохраняет его в атрибуте name.
- guess_name(self, guessed_name): метод, который проверяет, совпадает ли введённое имя с сохранённым именем, и возвращает соответствующее сообщение.
С помощью этих методов осуществляется проверка, угадал ли пользователь имя человека, заданное при создании объекта Person.

## Лабораторная работа №2
Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class IceCream:
    def __init__(self, topping=None):
        self.topping = topping
    def display(self):
        if isinstance(self.topping, str):
            print(f"Мороженое с {self.topping}")
        else:
            print("Обычное мороженое")
ice_cream1 = IceCream("шоколадом")
ice_cream1.display()
```
### Результат.
![image](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/92.png)

## Выводы
Код демонстрирует простую реализацию класса IceCream, который может иметь дополнительные ингредиенты (топпинги), и предоставляет способ отображать информацию о мороженом.

## Лабораторная работа №3
Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.

```python
class Encapsulation:
    def __init__(self, value):
        self.__value = value
    def set_value(self, value):
        self.__value = value
    def get_value(self):
        return self.__value
    def __del__(self):
        print(f"Объект с значением {self.__value} был уничтожен.")
encapsulation = Encapsulation(10)
print(encapsulation.get_value())
encapsulation.set_value(20)
print(encapsulation.get_value())
del encapsulation
```
### Результат.
![image](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/93.png)

## Выводы
Код демонстрирует принцип инкапсуляции в Python, где доступ к приватному полю осуществляется только через специальные методы set_value() и get_value().

## Лабораторная работа №4
Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    def __init__(self, species):
        self.species = species
class Cat(Mammal):
    def __init__(self, name):
        super().__init__("Кошка")
        self.name = name
class Dog(Mammal):
    def __init__(self, name):
        super().__init__("Собака")
        self.name = name
cat = Cat("Мурка")
dog = Dog("Шарик")
print(f"{cat.name} - {cat.species}")
print(f"{dog.name} - {dog.species}")
```
### Результат.
![image](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/94.png)

## Выводы
- Создан базовый класс Mammal, который имеет атрибут species.
- Созданы два дочерних класса Cat и Dog, которые наследуются от Mammal. В конструкторах этих классов вызывается конструктор базового класса с передачей соответствующих видов животных.
- Создаются объекты cat и dog классов Cat и Dog соответственно, с указанием имен.

## Лабораторная работа №5
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class RussianGreeting:
    greeting = "Привет"
    @staticmethod
    def greet():
        return RussianGreeting.greeting
class EnglishGreeting:
    greeting = "Hello"
    @staticmethod
    def greet():
        return EnglishGreeting.greeting
def greet_in_languages():
    print(RussianGreeting.greet())
    print(EnglishGreeting.greet())
greet_in_languages()
```
### Результат.
![image](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/95.png)

## Выводы
Код демонстрирует пример использования статических методов и переменных в Python для реализации приветствий на разных языках.


## Самостоятельная работа №1
Садовник и помидоры.  
```python
class Tomato:
    # Словарь состояний, описывающий этапы созревания томата
    states = {0: 'Отсутствует', 1: 'Цветение', 2: 'Зеленый', 3: 'Красный'}

    def __init__(self, index):
        """
        Инициализация объекта Tomato.

        Параметры:
        index (int): Индекс томата, используется для идентификации. (защищенный атрибут)

        state (int): Текущее состояние созревания томата. (защищенный атрибут)
        """
        self._index = index
        self._state = 0

    def grow(self):
        """
        Метод для перехода на следующую стадию созревания.
        Увеличивает текущее состояние созревания томата на 1.
        """
        self._state = self._state + 1

    def is_ripe(self):
        """
        Проверяет, достиг ли томат стадии зрелости.

        Возвращает:
        bool: True, если томат созрел (стадия 3), иначе False.
        """
        return self._state == 3


class TomatoBush:
    def __init__(self, tomato_num):
        """
        Инициализация объекта TomatoBush.

        Параметры:
        tomato_num (int): Количество томатов на кусте.

        tomatoes (list): Список объектов Tomato, представляющих томаты на кусте.
        """
        self.tomatoes = [Tomato(index) for index in range(tomato_num)]

    def grow_all(self):
        """
        Переводит все томаты на кусте на следующую стадию созревания.
        """
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """
        Проверяет, все ли томаты на кусте созрели.

        Возвращает:
        bool: True, если все томаты достигли стадии зрелости, иначе False.
        """
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """
        Удаляет все томаты с куста.
        """
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        """
        Инициализация объекта Gardener.

        Параметры:
        name (str): Имя садовника.
        plant (TomatoBush): Куст томатов, за которым ухаживает садовник.
        """
        self.name = name
        self._plant = plant

    def work(self):
        """
        Уход за кустом: переводит все томаты куста на следующую стадию созревания.
        """
        self._plant.grow_all()

    def harvest(self):
        """
        Сбор урожая, если все томаты на кусте созрели.

        Если все томаты достигли стадии зрелости, урожай собирается,
        и все томаты удаляются с куста. Если не все томаты созрели,
        выводится соответствующее сообщение.
        """
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print('Урожай собран')
        else:
            print('Томаты еще не созрели')

    @staticmethod
    def knowledge_base():
        """
        Вывод справочной информации о порядке действий для ухода за кустом томатов.
        """
        print("Справка по садоводству: ")
        print("1. Посадить куст томатов")
        print("2. Назначить садовника на куст")
        print("3. Ухаживать за кустом")
        print("4. Собрать урожай")


# Вызов справки
Gardener.knowledge_base()

# Создание куста с четырьмя томатами
bush = TomatoBush(4)

# Создание садовника и назначение его на куст томатов
gardener = Gardener('Катя', bush)

# Уход за кустом и попытка сбора урожая
gardener.work()
gardener.harvest()
gardener.work()
gardener.work()

# Сбор урожая
gardener.harvest()

```
### Тест 1. Вызов справки.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/911.png)
### Тест 2. Создание объектов классов TomatoBush и Gardener.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/912.png)
### Тест 3. Ухаживание за кустом через объект класса Gardener.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/913.png)
### Тест 4. Попытка сбора недозревших помидоров. Продолжение ухаживания.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/913.png)
### Тест 5. Сбор урожая.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/000.png)
### Результат.
![Меню](https://github.com/KaterinaFed9/software-engineering/blob/main/pic%7C/0000.png)
## Выводы
Класс Tomato:
- states: Статическое свойство, описывающее стадии созревания помидоров (отсутствует, цветение, зеленый, красный).
- init: Конструктор класса, задающий индекс помидора и начальную стадию созревания.
- grow(): Метод для перехода помидора на следующую стадию созревания. Проверяет текущее состояние и обновляет его.
- isripe()**: Метод для проверки, созрел ли помидор (если на стадии "красный").

Класс TomatoBush:
- init: Конструктор, который инициализирует куст помидоров с заданным количеством экземпляров класса Tomato.
- growall(): Метод, который заставляет все помидоры в кусте расти.
- allareripe(): Метод, проверяющий, все ли помидоры созрели (возвращает True или False).
- giveawayall(): Метод для полного удаления списка помидоров после сбора урожая.

Класс Gardener:
- init: Конструктор, принимающий имя садовника и растение (куст помидоров). Имя является публичным свойством, а растение - приватным.
- work(): Метод, позволяющий садовнику ухаживать за растением, вызывая его метод growall().
- harvest(): Метод, проверяющий возможность сбора урожая. Если все помидоры созрели, урожай собирается, иначе выводится предупреждение.
- knowledgebase(): Статический метод, печатающий советы по уходу за растениями.

Тесты:
- Демонстрация использования класса Gardener для ухода за кустом помидоров и сбора урожая.
- Проверка сбора урожая до созревания и после созревания с соответствующими выводами.

## Общие выводы по теме
Общие выводы по теме "Концепции и принципы ООП":

1. Объекты и классы:
   - Основная концепция ООП заключается в создании объектов на основе классов. Класс определяет структуру и поведение объектов, а объект является конкретным экземпляром этого класса.

2. Инкапсуляция:
   - Инкапсуляция (скрытие данных) позволяет ограничить доступ к внутренним состояниям объекта, предоставляя публичные методы для взаимодействия. Это помогает защищать данные от несанкционированного доступа и изменений, уменьшая вероятность ошибок.

3. Наследование:
   - Наследование позволяет создавать новые классы на основе существующих, наследуя их свойства и методы. Это способствует повторному использованию кода и облегчает его сопровождение. Наследующие классы могут добавлять или изменять поведение базового класса.

4. Полиморфизм:
   - Полиморфизм позволяет использования объектов разного типа через общий интерфейс. Это достигается за счет переопределения методов в дочерних классах, позволяя объектам вести себя по-разному, несмотря на единый интерфейс.

5. Абстракция:
   - Абстракция позволяет скрыть сложность системы, выделяя только наиболее важные особенности. Это достигается через создание абстрактных классов и интерфейсов, которые устанавливают контракт, что конкретные классы должны реализовать.

6. Композиция:
   - Композиция — это метод построения сложных объектов путём объединения нескольких простых объектов. Это альтернатива наследованию и позволяет создавать более гибкие и переиспользуемые компоненты.

7. Модульность:
    - ООП способствует модульности, позволяя разбивать код на самостоятельные компоненты (классы и модули), что облегчает разработку, тестирование и документацию.
